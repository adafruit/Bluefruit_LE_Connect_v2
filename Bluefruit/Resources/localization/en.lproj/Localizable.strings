// AUTO-GENERATED
// General


// Bluetooth Management

"bluetooth_unsupported" = "This device doesn't support Bluetooth Low Energy";
"bluetooth_notauthorized" = "This app is not authorized to use the Bluetooth Low Energy";
"bluetooth_poweredoff" = "Bluetooth is currently powered off";

"bluetooth_locationpermission_disabled_text" = "Location Services should be enabled to scan bluetooth peripherals.\nPlease, go to settings and enable it to start scanning peripherals";
"bluetooth_locationpermission_title" = "This app needs location access";
"bluetooth_locationpermission_text" = "Please grant location access so this app can scan for Bluetooth peripherals";
"bluetooth_locationpermission_notavailable_title" = "Bluetooth Scanning not available";
"bluetooth_locationpermission_notavailable_text" = "Since location access has not been granted, the app will not be able to scan for Bluetooth peripherals";
"bluetooth_scanner_errorregisteringapp" = "App cannot be registered for bluetooth scanning.
Please reset bluetooth and try again.";
"bluetooth_connecting_error" = "Error connecting to peripheral";
"bluetooth_advertising_start_error" = "Error starting advertising";

// Main Tab-Bar
"main_tabbar_singlemode" = "Select Device";
"main_tabbar_centralmode" = "Central Mode";
"main_tabbar_peripheralmode" = "Peripheral Mode";


// Scanner
"scanner_title" = "Peripherals";
"scanner_backbutton" = "Disconnect";
"scanner_splitmasterbutton" = "Peripheral List";
"scanner_subtitle" = "Peripherals found";
"scanner_uartavailable" = "Uart capable";
"scanner_beacon" = "Beacon";
"scanner_uribeacon" = "Uri-Beacon";
"scanner_notconnectable" = "Not Connectable";
"scanner_peripheraldisconnected" = "Peripheral disconnected";
"scanner_unnamed" = "<Unknown>";
"scanner_connect" = "Connect";
"scanner_disconnect" = "Disconnect";

"scanner_start_action" = "Start Scan";
"scanner_stop_action" = "Stop Scan";

"scanner_filter_name_title" = "Name:";
"scanner_filter_name_hint" = "Filter by name";
"scanner_filter_rssi_title" = "RSSI >=";
"scanner_filter_rssi_description_format" = "RSSI >= %ld";
"scanner_filter_unnamed_title" = "Show unnamed devices";
"scanner_filter_unnamed_description" = "with name";
"scanner_filter_uart_title" = "Must have UART Service";
"scanner_filter_uart_description" = "with UART";
"scanner_filter_name_matchsection" = "Match";
"scanner_filter_name_casesection" = "Case sensitivity";
"scanner_filter_currentfilter_format" = "Filter: %@";
"scanner_filter_nofilter" = "No filter selected";
"scanner_filter_rssivalue_format" = "%ld dBm";

"scanner_filter_name_settings_contains" = "Name contains";
"scanner_filter_name_settings_exact" = "Name equals";
"scanner_filter_name_settings_sensitive" = "Matching case";
"scanner_filter_name_settings_insensitive" = "Ignoring case";

"scanner_filteredoutinfo_single_format" = "%ld peripheral filtered out";
"scanner_filteredoutinfo_multiple_format" = "%ld peripherals filtered out";


// Scan Result
"scanresult_connect" = "Connect";
"scanresult_disconnect" = "Disconnect";

"scanresult_advertisement_viewrawdata" = "View Raw Data";
"scanresult_advertisement_rawdata_title" = "Advertising Raw Data";

"scanresult_advertisement_localname" = "Local name";
"scanresult_advertisement_address" = "Address";
"scanresult_advertisement_manufacturer" = "Manufacturer";
"scanresult_advertisement_services" = "Services";
"scanresult_advertisement_servicesuuids" = "Services UUIDs";
"scanresult_advertisement_overflowservices" = "Overflow services";
"scanresult_advertisement_servicesdata" = "Services data";
"scanresult_advertisement_servicesdata_uuid" = "UUID";
"scanresult_advertisement_servicesdata_data" = "Data";
"scanresult_advertisement_servicessolicited" = "Services solicited";
"scanresult_advertisement_connectable" = "Connectable";
"scanresult_advertisement_connectable_true" = "true";
"scanresult_advertisement_connectable_false" = "false";
"scanresult_advertisement_connectable_unknown" = "unknown";
"scanresult_advertisement_datapacket" = "Advertising packet data";
"scanresult_advertisement_txpower" = "TX Power Level";

"scanresult_advertisement_uribeacon_uri" = "Uri";
"scanresult_advertisement_beacon_uuid" = "UUID";
"scanresult_advertisement_beacon_major" = "Major";
"scanresult_advertisement_beacon_minor" = "Minor";


// Multiconnect Management
"multiconnect_title" = "Multiple UART mode";
"multiconnect_connecteddevices_single_format" = "Connected to %ld device";
"multiconnect_connecteddevices_multiple_format" = "Connected to %ld devices";
"multiconnect_start_action" = "Start";

// Peripheral Mode
"peripheral_advertisinginfo" = "Advertising Info";
"peripheral_localname" = "Local Name";
"peripheral_services" = "Services";
"peripheral_characteristics" = "Characteristics";

"peripheral_unknown_title" = "Undefined Peripheral";
"peripheral_dis_title" = "Device Information Service";
"peripheral_uart_title" = "UART";

"peripheral_notsupported" = "Peripheral mode is not supported on your device";
"peripheral_advertising_starterror_undefined" = "Peripheral mode can't not be started";
"peripheral_advertising_starterror_toolarge" = "Peripheral mode can't not be started: Advertising data too large";

// Peripheral Dis
"peripheral_dis_manufacturer" = "Manufacturer";
"peripheral_dis_modelnumber" = "Model Number";
"peripheral_dis_serialnumber" = "Serial Number";
"peripheral_dis_hardwarenumber" = "Hardware Number";
"peripheral_dis_firmwarerevision" = "Firmware Revision";
"peripheral_dis_softwarerevision" = "Software Revision";


// AutoUpdate Firmware
"autoupdate_title" = "Update available";
"autoupdate_description_format" = "Software version %@ is available";
"autoupdate_update" = "Go to updates";
"autoupdate_startupdate" = "Start update";
"autoupdate_later" = "Ask later";
"autoupdate_ignore" = "Ignore";


// Peripheral Details
"peripheraldetails_select" = "Connect to a peripheral from the list on the left";
"peripheraldetails_connecting" = "Connecting...";
"peripheraldetails_discoveringservices" = "Discovering services...";
"peripheraldetails_errordiscoveringservices" = "Error discovering peripheral services";
"peripheraldetails_checkingupdates" = "Checking updates...";

// Peripheral Modules
"peripheralmodules_title" = "Modules";
"peripheralmodules_sectiontitle_device_single" = "Device";
"peripheralmodules_sectiontitle_device_multiconnect" = "Multiple Devices";
"peripheralmodules_sectiontitle_modules" = "Modules";
"peripheralmodules_rssi_format" = "%ld dBm";
"peripheralmodules_rssi_unavailable" = "not available";
"peripheralmodules_battery_format" = "%ld%%";

// Info
"info_tab_title" = "Info";
"info_navigation_title_format" = "Info - %@";

"info_type_service" = "Service";
"info_type_characteristic" = "Characteristic";
"info_type_descriptor" = "Descriptor";
"info_data_hex" = "Data (Hex):";
"info_data_dec" = "Data (Dec):";

"info_uuid" = "UUID:";


"info_help_title" = "Info";
"info_help_text" = "• Each section of the table represents one of the peripheral's services followed by its relevant characteristics.

• If a service or characteristic uses a predefined UUID, a standardized name is displayed.  Otherwise the UUID value is shown.

• If a characteristic contains a readable value, that value is displayed at the bottom of the characteristic's table row";


// Uart
"uart_tab_title" = "UART";
"uart_navigation_title_format" = "UART - %@";


"uart_send_action" = "Send";
"uart_send_toall_action" = "To All";
"uart_send_toall_long" = "All Connected Peripherals";

"uart_sentbytes_format" = "Sent: %ld bytes";
"uart_receivedbytes_format" = "Received: %ld bytes";
"uart_timestamp_direction_rx" = "RX";
"uart_timestamp_direction_tx" = "TX";
"uart_text_dataomitted" = "(Previous data omitted to improve performance…)";

"uart_export_format_title" = "Export data";
"uart_export_format_subtitle" = "Choose the preferred format:";
"uart_export_nodata" = "No data to export";
"uart_export_save_message" = "Export Data to File";
"uart_export_save_prompt" = "Export";

"uart_settings_displayMode_title" = "Display Mode";
"uart_settings_displayMode_timestamp" = "Timestamp";
"uart_settings_displayMode_text" = "Text";
"uart_settings_displayMode_terminal" = "Terminal";
"uart_settings_dataMode_title" = "Data Mode";
"uart_settings_dataMode_hex" = "Hex";
"uart_settings_dataMode_ascii" = "Ascii";
"uart_settings_echo_title" = "Show Echo";
"uart_settings_eol_title" = "Send EoL";
"uart_settings_eolCharacters_title" = "EoL Characters";
"uart_eolmode_n" = "\\n";
"uart_eolmode_r" = "\\r";
"uart_eolmode_nr" = "\\n\\r";
"uart_eolmode_rn" = "\\r\\n";


"uart_settings_clear_title" = "Clear";
"uart_settings_export_title" = "Export...";

"uart_mqtt_action" = "MQTT";
"uart_mqtt_undefinedserver" = "Mqtt server not defined";
"uart_mqtt_editsettings" = "Edit Mqtt Settings";


"uart_mqtt_status_connected" = "Connected";
"uart_mqtt_status_connecting" = "Connecting...";
"uart_mqtt_status_disconnecting" = "Disconnecting...";
"uart_mqtt_status_error" = "Error";
"uart_mqtt_status_disconnected" = "Disconnected";

"uart_mqtt_connectionerror_title" = "MQTT Connection Error";


"uart_mqtt_subscription_localonly" = "Local Only";
"uart_mqtt_subscription_transmit" = "Transmit";

"uart_mqtt_qos_atleastonce" = "At Least Once";
"uart_mqtt_qos_atmostonce" = "At Most Once";
"uart_mqtt_qos_exactlyonce" = "Exactly Once";



"uart_help_title" = "UART";
"uart_help_text" = "Instructions:

• Tap the input field at the bottom of the screen.

• Enter the text string you want to send.

• Send a message by pressing the keyboard's Send button.

• Use the Timestamp/Text and ASCII/Hex control above the main console view to control the display format of messages.

• Use the Export button to copy or send the contents of the console.

• Use the Clear button to clear the console's contents.";
"uart_help_text_android" = "Instructions:

• Tap the input field at the bottom of the screen.

• Enter the text string you want to send.

• Send a message by pressing the keyboard's Send button.

• Use the Timestamp/Text and ASCII/Hex control above the main console view to control the display format of messages.";

"uart_error_peripheralinit" = "Uart protocol can not be initialized";
"uart_error_multipleperiperipheralinit_format" = "Uart protocol can not be initialized for peripheral: %@";

// Mqtt
"mqtt_connection_lost" = "Mqtt server connection failed";
"mqtt_connection_failed" = "Mqtt connection to server lost";

"uart_mqtt_settings_title" = "MQTT Settings";
"uart_mqtt_action_title" = "Mqtt Status:";
"uart_mqtt_action_connect" = "Connect";
"uart_mqtt_action_disconnect" = "Disconnect";

"uart_mqtt_settings_group_status" = "Status";
"uart_mqtt_settings_group_server" = "Server";
"uart_mqtt_settings_server_address" = "Address:";
"uart_mqtt_settings_server_port" = "Port:";
"uart_mqtt_settings_group_publish" = "Publish";
"uart_mqtt_settings_publish_rx" = "Uart RX:";
"uart_mqtt_settings_publish_tx" = "Uart TX:";
"uart_mqtt_settings_group_subscribe" = "Subscribe";
"uart_mqtt_settings_subscribe_topic" = "Topic:";
"uart_mqtt_settings_subscribe_action" = "Action:";
"uart_mqtt_settings_group_advanced" = "Advanced";
"uart_mqtt_settings_advanced_username" = "Username:";
"uart_mqtt_settings_advanced_password" = "Pass/Key:";
"uart_mqtt_settings_cleansession" = "Clean session:";
"uart_mqtt_settings_sslconnection" = "SSL connection:";
"uart_mqtt_qrconfig_action" = "Scan Code";
"uart_mqtt_qrconfig" = "Configure using AdafruitIO QR-Code";

"uart_mqtt_qrconfig_hint" = "Pich or strech to zoom the camera image";
"uart_mqtt_qrconfig_instructions" = "Point your device camera to the QR-Code and center it on the preview image
(The code will be automatically read when is visible)";


// Mqtt code reader

"mqttcodereader_cameraneeded" = "Access to the camera is needed for detection";
"mqttcodereader_lowstorageerror" = "Code detector dependencies cannot be downloaded due to low device storage. Please increase the available storage";
"mqttcodereader_nocamerapermission" = "Code detector cannot run because it does not have the camera permission";

// Plotter
"plotter_tab_title" = "Plotter";
"plotter_navigation_title_format" = "Plotter - %@";
"plotter_autoscroll" = "AutoScroll:";
"plotter_width" = "Width:";
"plotter_nodata" = "No chart data available";

"plotter_help_title" = "Plotter";
"plotter_help_text" = "• The 'Plotter' utility can be used to plot incoming numeric data in a chart, without having to create a custom plotter code or application. It behaves similarly to the Serial Plotter in recent versions of the Arduino IDE.

•  To plot one or more data streams to the plotter, send your numeric data in CSV format with one of the following seperators:
',' - Comma (0x2C)
' ' - Space (0x20)
';' - Semicolon (0x3B)
Horizontal Tab (0x09), '\\t' in code

Each unique set of data samples must be terminated by a LINE FEED character (0x0A), which is usually represented as '\\n' in code.

• Only numeric data should be sent over the BLE UART connection(s).";

// CircuitPython
"uart_circuitpython_title" = "CircuitPython";

// Dfu
"dfu_tab_title" = "Updates";
"dfu_navigation_title_format" = "Updates - %@";

"dfu_currentversion_title" = "Installed Firmware";
"dfu_firmwarereleases_title" = "Firmware Releases";
"dfu_bootloaderreleases_title" = "Bootloader Releases";

"dfu_firmware_format" = "Firmware: %@";
"dfu_betaversion_format" = "Beta Version %@";
"dfu_version_format" = "Version %@";

"dfu_choose_firmware_action" = "Use Custom Firmware";

"dfu_pickfiles_customfirmware_title" = "Select Custom Firmware";
"dfu_pickfiles_custombootloader_title" = "Select Custom Bootloader";
"dfu_pickfiles_hex_title" = "Hex File:";
"dfu_pickfiles_init_title" = "Init File:";
"dfu_pickfiles_hex_action" = "Choose";
"dfu_pickfiles_init_action" = "Choose";
"dfu_pickfiles_file_empty" = "<No file selected>";
"dfu_pickfiles_update_action" = "Start Update";
"dfu_pickfiles_error_hexmissing" = "At least an Hex file should be selected";
"dfu_pickfiles_error_noexplorer_title" = "Unavailable";
"dfu_pickfiles_error_noexplorer_message" = "File browser app not has not been found on your device. You should install an app like Dropbox, GoogleDrive…";


"dfu_install_action_title_format" = "Install firmware version %@?";
"dfu_install_action_message" = "The firmware will be downloaded and updated. Please wait until the process finishes before disconnecting the peripheral";
"dfu_unabletoupdate_bootloader_format" = "This firmware update is not compatible with your bootloader. You need to update your bootloader to version %@ before installing this firmware release %@";

"dfu_disnotavailable" = "Device Information Service not found. Unable to peform an OTA DFU update";
"dfu_dfunotavailable" = "No DFU Service found on device";
"dfu_legacybootloader" = "The legacy bootloader on this device is not compatible with this application";
"dfu_error_invalidfirmware" = "Firmware files not valid";
"dfu_error_bluetootherror" = "Bluetooth not ready";

"dfu_updatecompleted_message" = "Update completed successfully";
"dfu_updatecancelled_message" = "Update cancelled";
"dfu_updateaborted_message" = "Update aborted";
"dfu_download_hex_message" = "Downloading hex file";
"dfu_download_init_message" = "Downloading init file";
"dfu_download_firmware_message" = "Downloading firmware";
"dfu_download_bootloader_message" = "Downloading bootloader";
"dfu_download_error_message" = "Error downloading files. Check your internet connection and try again.";

"dfu_help_title" = "Firmware Updates";
"dfu_help_text" = "Instructions:

• Select one of the updates availables for the peripheral

• Use specific \"hex\" and \"init\" files to update your device. Please take into account that this could brick the peripheral if the firmware is not compatible";

// PinIO
"pinio_tab_title" = "Pin I/O";
"pinio_navigation_title_format" = "Pin I/O - %@";

"pinio_capabilityquery_querying_title" = "Querying pin capabilities...";

"pinio_capabilityquery_expired_title" = "No response to capability query";
"pinio_capabilityquery_expired_message" = "Assuming default pin format
(Arduino Uno)";

"pinio_pins_header" = "Available Pins";
"pinio_pintype_unknown" = "Unknown";
"pinio_pintype_input" = "Input";
"pinio_pintype_output" = "Output";
"pinio_pintype_pwm" = "PWM";
"pinio_pintype_servo" = "Servo";
"pinio_pintype_analog" = "Analog";
"pinio_pintype_low" = "Low";
"pinio_pintype_high" = "High";
"pinio_pintype_input_floating" = "Floating";
"pinio_pintype_inputfloating_long" = "Input Floating";
"pinio_pintype_input_pullup" = "Pull Up";
"pinio_pintype_inputpullup_long" = "Input Pullup";
"pinio_pinname_digital_format" = "Pin %ld";
"pinio_pinname_analog_format" = "Pin %ld, Analog %ld";
"pinio_tag_mode" = "Mode";

"pinio_help_title" = "Pin I/O";
"pinio_help_text" = "Instructions:

• The Pin I/O mode works with an Arduino board running the BLEFirmata sketch.  Detailed instructions can be found here:
https://learn.adafruit.com/bluefruit-le-connect-for-ios/pin-i-slash-o

• Tap a row in the table corresponding to the Arduino pin you want to control.

• Select a pin mode: 
   Input - monitor pin's state
   Output - enable setting of pin state
   Analog - monitor Analog pin input
   PWM - set a pin's pulse width  output

• Set an Output pin's state using the Low/High control.

• Set a PWM pin's output value using the slider control.

• Once finished setting a pin's mode or state, you can close it by tapping the empty space near it's top - or by selecting another row.";

// Controller
"controller_tab_title" = "Controller";
"controller_navigation_title_format" = "Controller - %@";

"controller_uartwarning" = "Please ensure that your Bluefruit LE module is set to DATA/UART mode when using this module";

"controller_sensor_title" = "Stream Sensor Data";
"controller_module_title" = "Module";

"controller_sensor_quaternion" = "Quaternion";
"controller_sensor_accelerometer" = "Accelerometer";
"controller_sensor_gyro" = "Gyro";
"controller_sensor_magnetometer" = "Magnetometer";
"controller_sensor_location" = "Location";

"controller_component_lat" = "lat";
"controller_component_long" = "long";
"controller_component_alt" = "alt";
"controller_component_x" = "x";
"controller_component_y" = "y";
"controller_component_z" = "z";
"controller_component_w" = "w";

"controller_sensor_location_disabled" = "Location Services Disabled";
"controller_sensor_location_restricted" = "This module is not authorized to use location services";
"controller_sensor_location_denied" = "Location Services are disabled. Go to settings and enable location services for this app to use this feature.";
"controller_sensor_locationpermission_text" = "Please grant fine location access to show the current location";
"controller_location_unknown" = "Waiting for location data…";
"controller_magnetometermissing" = "Your device doesn't have a magnetic sensor";

"controller_module_pad" = "Control Pad";
"controller_module_colorpicker" = "Color Picker";

"controller_help_title" = "Controller";
"controller_help_text_ios_android" = "The Controller module streams sensor data from your iOS device to Bluefruit LE over UART at a frequency of 10Hz. Activation of a switch will begin sending relevant data. Each packet sent begins with single byte char “!” (0x21) followed by a single byte char initial, and sensor data encoded as float values of 4 byte length

• Quaternion sends iOS Device Motion data to describe device attitude. This data is derived from Accelerometer, Gyro, and Magnetometer readings.
Format: [ ‘!’ ] [ ‘Q’ ] [ float x ] [ float y ] [ float z ] [ float w ]

• Accelerometer sends raw accelerometer data
Format: [ ‘!’ ] [ ‘A’ ] [ float x ] [ float y ] [ float z ]

• Gyro sends raw gyroscope data as:
Format: [ ‘!’ ] [ ‘G’ ] [ float x ] [ float y ] [ float z ]

• Magnetometer sends raw magnetometer data which is uncalibrated and does not account for interference from source device.
Format: [ ‘!’ ] [ ‘M’ ] [ float x ] [ float y ] [ float z ]

• Location sends GPS data and requires user permission before initial use.
Format: [ ‘!’ ] [ ‘L’ ] [ float latitude ] [ float longitude ] [ float altitude ]";
"controller_help_text_mac" = "The Controller module streams sensor data from your computer to Bluefruit LE over UART at a frequency of 10Hz. Activation of a switch will begin sending relevant data. Each packet sent begins with single byte char “!” (0x21) followed by a single byte char initial, and sensor data encoded as float values of 4 byte length

• Location sends GPS data and requires user permission before initial use.
Format: [ ‘!’ ] [ ‘L’ ] [ float latitude ] [ float longitude ] [ float altitude ]";

// Control Pad

"controlpad_title" = "Control Pad";

"controlpad_help_title" = "Control Pad";
"controlpad_help_text" = "The Control Pad function provides a familiar momentary button interface for common control scenarios. Data is sent on the press and release of each button. Each packet consists of 4 bytes, each representing a char value. The first two chars identify the packet as a button message, the third specifies a button, and the fourth signifies either a press or release. Example:

Button 4 pressed:  [ ‘!’ ] [ ‘B’ ] [ ‘4’ ] [ ‘1’ ]
Button 4 released: [ ‘!’ ] [ ‘B’ ] [ ‘4’ ] [ ‘0’ ]

Note: Any activated sensor data streams will continue while using the Control Pad.";

// Color Picker

"colorpicker_title" = "Color Picker";

"colorpicker_brightness" = "Brightness:";
"colorpicker_saturation" = "Saturation:";
"colorpicker_wcomponent" = "W component:";
"colorpicker_rgb_format" = "RGB: %ld-%ld-%ld";
"colorpicker_rgbw_format" = "RGBW: %ld-%ld-%ld-%ld";
"colorpicker_hex_format" = "Hex: %@";
"colorpicker_select_action" = "Select";

"colorpicker_boardselector_action" = "Board Selector";
"colorpicker_boardtype_action" = "Board Type";


"colorpicker_help_title" = "Color Picker";
"colorpicker_help_text" = "The Color Picker sends a color's RGB values to Bluefruit LE.  This can be used to control the state of RGB LEDs such as Neopixels.

• Touch the color wheel to choose desired color

• Press Send to send the chosen color's red, green, and blue values to Bluefruit via UART in the following format:
[ ‘!’ ] [ ‘C’ ] [ byte r ] [ byte g ] [ byte b ]";


// NeoPixels
"neopixels_tab_title" = "Neopixels";
"neopixels_navigation_title_format" = "Neopixels - %@";

"neopixels_status_title" = "Status:";
"neopixels_connect_action" = "Connect";

"neopixels_waitingforuart" = "Waiting for Uart...";
"neopixels_status_readytoconnect" = "Ready to Connect";
"neopixels_status_waitingsetup" = "Waiting for Setup";
"neopixels_status_readyforsetup" = "Ready for Setup";
"neopixels_status_connected" = "Connected";
"neopixels_status_checkingsketch" = "Checking Sketch...";
"neopixels_status_notdetected" = "Not detected";

"neopixels_picker_title" = "Picker:";
"neopixels_brightness_title" = "Brightness:";
"neopixels_colorpicker_setcolor" = "Set";

"neopixel_help_title" = "NeoPixels";
"neopixel_help_text" = "To use the NeoPixel application:

• Open Bluefruit LE Connect Neopixel sketch on the Arduino IDE and run it
• Connect to your Bluefruit module and switch to the NeoPixel utility
• Click the 'gear' icon and set your board size (8x4, 1x8, etc.)
• Click the Connect button in the Bluefruit LE Connect app
• Select a color and tap individual pixels to set them
• Adjust overall brightness as desired using the Brightness slider";
"neopixel_sketch_tooltip" = "Neopixel support requires a custom sketch to be running on your Arduino.";

// Neopixels Board Selector
"neopixelboardselector_standardboardsizes_title" = "Standard board sizes";
"neopixelboardselector_customboardsize_title" = "Custom board size";
"neopixelboardselector_customboardsize_linestrip" = "Line Strip";
"neopixelboardselector_linestriplength_title" = "Select line strip length";
"neopixelboardselector_linestriplength_hint" = "Enter length";
"neopixelboardselector_linestriplength_action" = "Select";

// Neopixels Component Selector
"neopixelcomponentselector_speed_title" = "Speed";
"neopixelcomponentselector_pixelorder_title" = "Pixel Order";
"neopixelcomponentselector_speed_400khz" = "400 Khz Mode";

// Calibration
"calibration_tab_title" = "AHRS/Calibration";
"calibration_navigation_title_format" = "AHRS/Calibration - %@";

// Thermal Camera
"thermalcamera_tab_title" = "Thermal Camera";
"thermalcamera_navigation_title_format" = "Thermal Camera - %@";

"thermalcamera_waitingforuart" = "Waiting for Uart...";
"thermalcamera_colormode_title" = "Color Mode:";
"thermalcamera_colormode_color" = "Color";
"thermalcamera_colormode_monochrome" = "Monochrome";
"thermalcamera_magnification_title" = "Magnification:";
"thermalcamera_magnification_pixelated" = "Pixelated";
"thermalcamera_magnification_filtered" = "Filtered";

"thermalcamera_temprange_title" = "Temperature Range:";

// Image Transfer
"imagetransfer_tab_title" = "Image Transfer";
"imagetransfer_navigation_title_format" = "Image Transfer - %@";

"imagetransfer_help_title" = "Image Transfer";
"imagetransfer_help_text" = "The Image Transfer module sends the image of your choice to Bluefruit LE over UART.

Format:
- single byte char “!” (0x21)
- single byte char 'I' (0x49)
- bit depth (uint8 16 for 16bits 565 or 24 for 24-bit 888)
- image width (uint16 little endian, 2 bytes)
- height (uint16 little endian, 2 bytes)
- pixel data encoded as \"RGB 16bit 565” or \"RGB 24-bit 888\" depending on the Bit Depth selected
- single byte CRC

Resolution:
Choosing a resolution determines the pixel dimensions in [width] x [height]. Switching to E-ink mode provides access to common e-ink screen dimensions and converts the resulting image's color to black, white, & red using a dithering algorithm specially designed for e-ink displays.

Transfer mode:
This setting affects the speed of the data transfer. The recommended value is “Interleaved [50:1]”
Take into account that data could be lost if the speed is too fast and your phone or the Bluefruit LE peripheral are not able to process it fast enough.

The possible values for Transfer mode are:
- Without response: Send packets without waiting for acknowledgement. This is the fastest method.
- With response: Send each packet waiting for acknowledgment. This is the slowest and safest method.
- Interleaved: sends a number of packets without response for each packet with response.


";
"imagetransfer_help_text_macos_noeink" = "The Image Transfer module sends the image of your choice to Bluefruit LE over UART.

Format:
- single byte char “!” (0x21)
- single byte char 'I' (0x49)
- bit depth (uint8 16 for 16bits 565 or 24 for 24-bit 888)
- image width (uint16 little endian, 2 bytes)
- height (uint16 little endian, 2 bytes)
- pixel data encoded as \"RGB 16bit 565” or \"RGB 24-bit 888\" depending on the Bit Depth selected
- single byte CRC

Resolution:
Choosing a resolution determines the pixel dimensions in [width] x [height].

Transfer mode:
This setting affects the speed of the data transfer. The recommended value is “Interleaved [50:1]”
Take into account that data could be lost if the speed is too fast and your device or the Bluefruit LE peripheral are not able to process it fast enough.

The possible values for Transfer mode are:
- Without response: Send packets without waiting for acknowledgement. This is the fastest method.
- With response: Send each packet waiting for acknowledgment. This is the slowest and safest method.
- Interleaved: sends a number of packets without response for each packet with response.


";

"imagetransfer_waitingforuart" = "Waiting for Uart...";
"imagetransfer_resolution_title" = "Resolution:";
"imagetransfer_resolution_einkprefix" = "E-Ink";
"imagetransfer_resolution_value_default" = "Default";
"imagetransfer_image_title" = "Image:";
"imagetransfer_image_value_default" = "Default";
"imagetransfer_transfermode_title" = "Transfer mode:";
"imagetransfer_transfermode_value_withresponse" = "With Response";
"imagetransfer_transfermode_value_withoutresponse" = "Without Response";
"imagetransfer_transfermode_value_interleaved" = "Interleaved";
"imagetransfer_transfermode_value_interleaved_format" = "Interleaved [%ld : 1]";
"imagetransfer_transfermode_interleavedcount_title" = "Interleaved";
"imagetransfer_transfermode_interleavedcount_message" = "Number of packets without response for each packet with response (default value = 50)";
"imagetransfer_transfermode_interleavedcount_hint" = "Enter number";

"imagetransfer_selectimage_action" = "Select image";
"imagetransfer_imagepicker_camera" = "Take photo";
"imagetransfer_imagepicker_cameraroll" = "Camera roll";
"imagetransfer_imagepicker_photolibrary" = "Photo library";
"imagetransfer_imagepicker_filepicker" = "Open file...";
"imagetransfer_imageorigin_choose" = "Choose Image";
"imagetransfer_resolution_choose" = "Choose Resolution";
"imagetransfer_resolution_mode_standard" = "Standard";
"imagetransfer_resolution_mode_eink" = "E-Ink";
"imagetransfer_send_action" = "Send Image";
"imagetransfer_cameranotavailable" = "Camera is not available";
"imagetransfer_decodeimage_error" = "Image cannot be decoded";
"imagetransfer_outofmemory_error" = "Image too big for available memory";
"imagetransfer_transferring" = "Sending image...";
"imagetransfer_senddata_error" = "There was an error while transferring the image data";
"imagetransfer_crop_action" = "Crop image";
"imagetransfer_crop_error" = "Error cropping image ";
"imagetransfer_colorspace_title" = "Bit Depth:";
"imagetransfer_colorspace_16bit" = "16-bit";
"imagetransfer_colorspace_24bit" = "24-bit";

"imagetransfer_cameraneeded" = "Access to the camera is needed to take pictures";
"imagetransfer_readexternalneeded" = "Access to the media library is needed to choose picture";




// Common
"dialog_ok" = "OK";
"dialog_cancel" = "Cancel";
"dialog_error" = "Error";
"dialog_notice" = "Notice";
"dialog_dontshowagain" = "Don't show again";

"common_help_action" = "Help";


// About
"about_title" = "About";
"about_app_name" = "Bluefruit LE Connect";
"about_android_text" = "A detailed guide to using this app can be found here:
https://learn.adafruit.com/bluefruit-le-connect

Configure your Bluefruit LE hardware using instructions found here:
http://www.adafruit.com/bluefruitle

Drag the table down and release to clear the list of found peripherals and begin scanning

Tap a row in the table to view a peripheral's advertisement data.

Each peripheral's Received Signal Strength (RSSI) is displayed to the left of its name.

Tap a row's connect button to connect the corresponding device in one of the available modes:

• Info - displays peripheral services & characteristics

• UART - basic terminal, send & receive data 

• Plotter - plot incoming numeric data in a chart

• Pin I/O - uses Bluefruit's UART to control Arduino running BLEFirmata sketch:
https://learn.adafruit.com/getting-started-with-the-nrf8001-bluefruit-le-breakout/software-bluefruit-firmata

• Controller - streams sensor data from your device to Bluefruit LE over UART

• Neopixels - control NeoPixels individually with an interactive color picker

• Image Transfer - send an image to Bluefruit LE over UART

• Updates - update device firmware



Acknowledgements

Portions of this Software may utilize the following copyrighted material, the use of which is hereby acknowledged. 

Android-DFU-Library
Copyright (c) 2015, Nordic Semiconductor
https://github.com/NordicSemiconductor/Android-DFU-Library

Android-Scanner-Compat-Library
Copyright (c) 2015, Nordic Semiconductor
https://github.com/NordicSemiconductor/Android-Scanner-Compat-Library

Eclipse Paho
https://eclipse.org/paho/clients/java/

MPAndroidChart
https://github.com/PhilJay/MPAndroidChart

Android Vision Sample for Barcode Reading
Copyright (C) The Android Open Source Project
Licensed under the Apache License, Version 2.0

ImageCropView
Copyright (c) 2015 Naver Corp.
Author Ohkyun Kim
https://github.com/naver/android-imagecropview

ImageMagick6
Copyright © 1999-2017 ImageMagick Studio LLC
https://github.com/ImageMagick/ImageMagick6

Android-ImageMagick
Copyright (c) 2018 paulasiimwe
https://github.com/paulasiimwe/Android-ImageMagick";
"about_ios_text" = "A detailed guide to using this app can be found here:
https://learn.adafruit.com/bluefruit-le-connect

Configure your Bluefruit LE hardware using instructions found here:
http://www.adafruit.com/bluefruitle

Drag the table down and release to clear the list of found peripherals and begin scanning

Tap a row in the table to view a peripheral's advertisement data.

Each peripheral's Received Signal Strength (RSSI) is displayed to the left of its name.

Tap a row's connect button to connect the corresponding device in one of the available modes:

• Info - displays peripheral services & characteristics

• UART - basic terminal, send & receive data 

• Plotter - plot incoming numeric data in a chart

• Pin I/O - uses Bluefruit's UART to control Arduino running BLEFirmata sketch:
https://learn.adafruit.com/getting-started-with-the-nrf8001-bluefruit-le-breakout/software-bluefruit-firmata

• Controller - streams sensor data from your device to Bluefruit LE over UART

• Neopixels - control NeoPixels individually with an interactive color picker

• Image Transfer - send an image to Bluefruit LE over UART

• Updates - update device firmware



Acknowledgements

Portions of this Software may utilize the following copyrighted material, the use of which is hereby acknowledged. 

IOS-Pods-DFU-Library
Copyright (c) 2016, Nordic Semiconductor
https://github.com/NordicSemiconductor/IOS-Pods-DFU-Library

CocoaMQTT
Copyright (c) 2014 emqtt
https://github.com/emqtt/CocoaMQTT

SwiftyXML
Copyright (c) 2016 ChenYunGui (陈云贵)
https://github.com/chenyunguiMilook/SwiftyXML

Charts
Copyright 2016 Daniel Cohen Gindi & Philipp Jahoda
https://github.com/danielgindi/Charts

iOS-Color-Wheel
https://github.com/justinmeiners/ios-color-wheel

UIColor-Hex
Copyright (C) 2011-2014, Tom Adriaenssen
https://github.com/Inferis/UIColor-Hex

VectorMath
Copyright (c) 2014 Nick Lockwood. All rights reserved.
https://github.com/nicklockwood/VectorMath

ImageMagick6
Copyright © 1999-2017 ImageMagick Studio LLC
https://github.com/ImageMagick/ImageMagick6";
